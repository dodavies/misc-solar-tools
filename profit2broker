// sa_ws_profit.c
// Fetches http://192.168.0.177/totals, extracts two numbers (Used kWh, Export kWh),
// computes profit, publishes to MQTT. That's it.

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <curl/curl.h>
#include "MQTTClient.h"

// ---- CONFIG (edit if needed) ----
#define TOTALS_URL   "http://192.168.0.177/totals"

#define MQTT_HOST     "tcp://192.168.0.160:1883"
#define MQTT_CLIENTID "sa-profit-publisher"
#define MQTT_USER     "mqttuser"
#define MQTT_PASS     "mqttuser"
#define MQTT_TOPIC    "home/solar/profit"

#define IMPORT_TARIFF 0.07   // £/kWh
#define EXPORT_TARIFF 0.15   // £/kWh
// ---------------------------------

struct mem { char *data; size_t len; };
static size_t write_cb(void *ptr, size_t size, size_t nmemb, void *ud) {
    size_t n = size * nmemb;
    struct mem *m = (struct mem*)ud;
    char *p = (char*)realloc(m->data, m->len + n + 1);
    if (!p) return 0;
    m->data = p;
    memcpy(m->data + m->len, ptr, n);
    m->len += n;
    m->data[m->len] = 0;
    return n;
}

static int http_get(const char *url, struct mem *out) {
    CURL *c = curl_easy_init();
    if (!c) return -1;
    curl_easy_setopt(c, CURLOPT_URL, url);
    curl_easy_setopt(c, CURLOPT_FOLLOWLOCATION, 1L);
    curl_easy_setopt(c, CURLOPT_USERAGENT, "curl/7");
    curl_easy_setopt(c, CURLOPT_WRITEFUNCTION, write_cb);
    curl_easy_setopt(c, CURLOPT_WRITEDATA, out);
    curl_easy_setopt(c, CURLOPT_CONNECTTIMEOUT, 4L);
    curl_easy_setopt(c, CURLOPT_TIMEOUT, 8L);
    CURLcode rc = curl_easy_perform(c);
    curl_easy_cleanup(c);
    return rc == CURLE_OK ? 0 : -1;
}

// Find first float starting at/after idx; returns end index or -1
static long scan_float(const char *s, long idx, double *out) {
    while (s[idx] && !(isdigit((unsigned char)s[idx]) || s[idx]=='.' || s[idx]=='-' )) idx++;
    if (!s[idx]) return -1;
    char buf[64]; int bi=0;
    while (s[idx] && (isdigit((unsigned char)s[idx]) || s[idx]=='.' || s[idx]=='e' || s[idx]=='E' || s[idx]=='+' || s[idx]=='-')) {
        if (bi < (int)sizeof(buf)-1) buf[bi++] = s[idx];
        idx++;
    }
    buf[bi] = 0;
    *out = atof(buf);
    return idx;
}

static char *istrstr(const char *h, const char *n) { // case-insensitive strstr
    if (!*n) return (char*)h;
    size_t nl = strlen(n);
    for (const char *p=h; *p; p++) if (tolower((unsigned char)*p) == tolower((unsigned char)*n))
        if (strncasecmp(p,n,nl)==0) return (char*)p;
    return NULL;
}

// Tries:
// 1) Labeled: "used" ... number, "export" ... number (case-insensitive)
// 2) First two floats in the document
static int extract_two_numbers(const char *s, double *used, double *exp) {
    const char *p_used = istrstr(s, "used");
    const char *p_export = istrstr(s, "export");
    long i; double a,b;

    if (p_used && p_export) {
        long uidx = (long)(p_used - s);
        long eidx = (long)(p_export - s);
        long uend = scan_float(s, uidx, &a);
        long eend = scan_float(s, eidx, &b);
        if (uend != -1 && eend != -1) { *used = a; *exp = b; return 1; }
    }
    // Fallback: first two floats anywhere
    i = 0;
    long e1 = scan_float(s, i, &a);
    if (e1 == -1) return 0;
    long e2 = scan_float(s, e1, &b);
    if (e2 == -1) return 0;
    *used = a; *exp = b;
    return 1;
}

int main(void) {
    curl_global_init(CURL_GLOBAL_DEFAULT);

    struct mem page = {0};
    if (http_get(TOTALS_URL, &page) != 0 || !page.data || !page.len) {
        fprintf(stderr, "Failed to fetch %s\n", TOTALS_URL);
        curl_global_cleanup();
        return 1;
    }

    double used=-1, exp=-1;
    if (!extract_two_numbers(page.data, &used, &exp)) {
        fprintf(stderr, "Could not parse two numbers from %s\n", TOTALS_URL);
        free(page.data);
        curl_global_cleanup();
        return 2;
    }
    free(page.data);

    double profit = exp * EXPORT_TARIFF - used * IMPORT_TARIFF;
    printf("Used: %.3f kWh, Exported: %.3f kWh -> Profit: %.3f (£)\n", used, exp, profit);

    // Publish to MQTT (tiny)
    MQTTClient cli;
    MQTTClient_connectOptions opts = MQTTClient_connectOptions_initializer;
    MQTTClient_create(&cli, MQTT_HOST, MQTT_CLIENTID, MQTTCLIENT_PERSISTENCE_NONE, NULL);
    opts.keepAliveInterval = 15;
    opts.cleansession = 1;
    opts.username = MQTT_USER;
    opts.password = MQTT_PASS;

    if (MQTTClient_connect(cli, &opts) == MQTTCLIENT_SUCCESS) {
        char payload[64];
        snprintf(payload, sizeof(payload), "%.3f", profit);
        MQTTClient_message msg = MQTTClient_message_initializer;
        msg.payload = payload;
        msg.payloadlen = (int)strlen(payload);
        msg.qos = 1;
        msg.retained = 0;
        MQTTClient_deliveryToken tok;
        MQTTClient_publishMessage(cli, MQTT_TOPIC, &msg, &tok);
        MQTTClient_waitForCompletion(cli, tok, 1500);
        MQTTClient_disconnect(cli, 1000);
    } else {
        fprintf(stderr, "MQTT connect failed (skipping publish)\n");
    }
    MQTTClient_destroy(&cli);
    curl_global_cleanup();
    return 0;
}
